---
title: "낙관적 업데이트와 React useOptimistic 훅"
description: 낙관적 업데이트와 React 19에 새롭게 추가된 useOptimistic 훅에 대해서 알아봅니다.
date: 2025-01-31 23:30:00
toc: true
tags:
  - react
  - optimistic updates
---

항해를 마친 후 새로운 기술 스터디를 시작했습니다.<br />
평소 회사에서는 vue를 사용하기 때문에 리액트의 새로운 기능에 대해서 알아보고 싶었고, 이를 통해서 여러 인사이트를 얻기 위해서 공식문서를 통해 새롭게 나온 기술에 대해서 학습해보는 시간을 가졌습니다.<br />
여러 훅이 새로 추가됐지만 그 중에서도 `useOptimistic`에 대해서 자세하게 알아봤습니다.

## 낙관적 업데이트(Optimistic Updates)란?

> **네트워크 요청과 같이 비동기 작업이 완료되는 것을 기다리지 않고, UI를 먼저 기대되는 결과로 업데이트하는 것**을 말합니다.
사용자는 동작에 대한 피드백을 빨리 받아 애플리케이션이 빠르게 동작한다고 느낄 수 있고, 사용자 경험을 향상할 수 있습니다.

낙관적 업데이트의 핵심 아이디어는 다음과 같습니다.

1. 사용자 액션(ex 좋아요 버튼 클릭)
2. 버튼 클릭과 동시에 사용자의 화면을 기대하는 결과로 즉시 업데이트
3. 서버에 네트워크 요청을 보냄
4. 네트워크 요청이 완료되면 서버의 응답으로 화면을 업데이트
5. 요청이 실패할 경우 이전 상태로 다시 돌아가거나 얼럿 메시지를 제공하여 사용자에게 요청이 실패했다는 피드백을 제공

---

## React19 useOptimistic 훅

리액트 19 버전에서 낙관적 업데이트를 쉽게 구현할 수 있는 `useOptimistic` 훅이 새롭게 추가됐습니다.<br />
공식 문서에서도 `useOptimistic` 훅에 대해서 다음과 같이 설명하고 있습니다.

> useOptimistic은 React Hook으로, 비동기 작업이 진행 중일 때 다른 상태를 보여줄 수 있게 해줍니다.

useOptimistic 훅을 이해하기 위해서 간단한 좋아요 버튼 컴포넌트를 구현했습니다.

<details>
<summary><b>전체 코드 보기</b></summary>

```tsx
import { Heart } from "lucide-react";
import { useOptimistic, useTransition, useState, useEffect } from "react";

interface State {
	isLike: boolean
	count: number
}

export default function LikeButton() {
	const [state, setState] = useState<State>({ 
		isLike: false,
		count: 0
	})

	const [error, setError] = useState('')

	const [optimisticState, toggleOptimisticIsLike] = useOptimistic<State, State['isLike']>(state, (currentState, optimisticValue) => {
		return {
			isLike: optimisticValue,
			count: optimisticValue ? currentState.count + 1 : currentState.count - 1
		}
	})

	const [isPending, startTransition] = useTransition()

	useEffect(() => {
		const fetchData = async () => {
      const response = await fetch('/api/like', { method: 'GET' })
      const data = (await response.json()) as { isLike: boolean; count: number }
			setState(data)
    }

    fetchData();
	}, [])

	const addLike = async () => {
		try {
			const response = await fetch('/api/like', { method: 'POST' })
			if (!response.ok) {
				throw new Error('Server Error...')
			}
			const data = (await response.json()) as { isLike: boolean; count: number }
			setState(data)
		} catch (error) {
			if (error instanceof Error) {
				setError(error.message)
			}
		}
	}

	const removeLike = async () => {
		const response = await fetch('/api/like', { method: 'DELETE' })
		const data = (await response.json()) as { isLike: boolean; count: number }
		setState(data)
	}

	const handleClick = () => {
		startTransition(async () => {
			const nextIsLike = !optimisticState.isLike
			toggleOptimisticIsLike(nextIsLike)

			if (nextIsLike === true) {
				await addLike()
			} else {
				await removeLike()
			}
		})
	}

	const heartIcon = optimisticState.isLike ? <Heart color="#d04e4e" fill="#d04e4e" size={80} /> : <Heart color="#d04e4e" size={80} />

	return (
		<button type="button" className="flex flex-col gap-2 justify-center items-center" onClick={handleClick}>
			{heartIcon}
			<span className="text-4xl text-center text-slate-600 font-semibold">{optimisticState.count}</span>
			{isPending && <div className="text-2xl text-center text-slate-600">loading...</div>}
			{error && <div className="text-xl text-center text-red-600">{error}</div>}
		</button>
	)
}
```
</details>

---

### useOptimistic 훅 선언
```tsx
// LikeButton.tsx
function LikeButton() {
  const [optimisticState, toggleOptimisticIsLike] = useOptimistic<State, Value>(
  // state
  {
    isLike: false,
    count: 0
  },
  // updateFn
  (currentState: State, optimisticValue: Value): State => {
    return {
      isLike: optimisticValue,
      count: optimisticValue ? currentState.count + 1 : currentState.count - 1
    }
  })

  return <button></button>
}
```
`useOptimistic` 훅의 매개변수

- state
  - 훅의 초기 값을 지정합니다.
  - 이번 예제에서는 현재 좋아요 상태와 좋아요 개수를 관리하기 위해서 객체를 사용했습니다.
- updateFn
  - `optimisticState`(낙관적인 상태)를 계산하여 반환하는 함수입니다.
  - 첫 번째 매개변수는 현재 상태, 두 번째 매개변수는 `toggleOptimisticIsLike` 함수의 인자로 전달된 값입니다.
  - `toggleOptimisticIsLike` 함수가 호출되면 새로운 상태를 계산하여 반환합니다.

`useOptimistic` 훅의 리턴 값

- optimisticState
  - 비동기 작업이 진행 중인 동안에 사용자에게 보여줄 낙관적인 상태입니다.
  - 비동기 작업이 진행 중일 경우 `updateFn` 함수가 반환한 값과 동일한 값을 가집니다.
  - 비동기 작업이 진행 중이지 않을 경우 초기 `state`와 동일한 값(state가 객체일 경우 동일한 참조)을 가집니다.
- toggleOptimisticIsLike
  - `toggleOptimisticIsLike` 함수를 호출하면 `updateFn`이 호출되어 `optimisticState`가 업데이트됩니다.
  - 호출 시 전달 받은 인자가 `updateFn`의 두 번째 인자로 전달됩니다.

---

### 좋아요 버튼 클릭 이벤트 핸들러 구현
```tsx
const handleClick = () => {
  startTransition(async () => {
    // 💡 낙관적 업데이트
    toggleOptimisticIsLike(!optimisticState.isLike)

    // API 요청을 시뮬레이션하기 위해 2초의 지연 설정
    await new Promise<void>((resolve) => {
      setTimeout(resolve, 2000)
    })
  })
}
```
- `startTransition` 함수의 콜백 함수 내부에서 `toggleOptimisticIsLike` 함수와 api를 호출합니다.
- `toggleOptimisticIsLike`가 호출되면 `updateFn`이 실행되고, 네트워크 요청을 보내기 전에 사용자의 화면이 먼저 업데이트 됩니다.
- 타이머가 종료되어 프로미스가 resolve되면, `optimisticState`는 다시 초기 상태로 되돌아갑니다.

```tsx title="updateFn의 동작 방식"
// 1. 기존 상태가 { isLike: false, count: 3 } 일 때
toggleOptimisticIsLike(true)

const newState = updateFn({ isLike: false, count: 3 }, true)
// => { isLike: true, count: 4 } 반환

// 2. 기존 상태가 { isLike: true, count: 4 } 일 때
toggleOptimisticIsLike(false)

const newState = updateFn({ isLike: true, count: 4 }, false)
// => { isLike: false, count: 3 } 반환
```

-> 사용자의 화면에는 아래 이미지처럼 보여집니다.

![](/posts/react-use-optimistic/example-1.gif)

낙관적 업데이트가 적용된 후 다시 초기 상태로 되돌아가는 것을 확인할 수 있습니다.<br />
`useOptimistic`이 단독으로 사용될 경우, 컴포넌트가 리렌더링 될 때마다 초기 `state` 값으로 다시 설정되기 때문입니다.

---

#### ✔ `useOptimistic` 훅을 사용할 때 `startTransition`과 함께 사용해야 하는 이유

`startTransition`의 인자로 전달되는 콜백 함수를 액션이라고 부르는데, `useOptimistic`을 이용해서 낙관적인 업데이트를 적용하려면 `startTransition`이나 React form action 안에서 사용해야 합니다.

-> 그렇지 않으면 다음과 같은 에러 메시지가 출력됩니다.
```text
An optimistic state update occurred outside a transition or action. 
To fix, move the update to an action, or wrap with startTransition.
```

#### ✔ `startTransition`을 사용하는 두 가지 방법

```jsx
// 1. react 패키지에서 import
import { startTransition } from 'react'
```

```jsx
// 2. useTransition 훅과 함께 사용
const [isPending, startTransition] = useTransition()
```
- 로딩 상태를 추가로 관리해야 할 경우 useTransition 훅을 사용합니다.
- `startTransition`의 인자로 전달된 액션이 실행 중인 동안 isPending은 true 값을 유지합니다.

---

### 서버 상태를 관리하기 위해 `useState` 선언

`optimisticState`가 다시 초기 값으로 돌아가는 문제를 해결하려면 서버에서 변경된 상태를 `useOptimistic`의 초기 상태와 동기화해야 합니다.<br />
이를 위해 `useState`를 사용하여 서버 상태를 관리하고, `useOptimistic`의 초기 값으로 설정하는 코드를 추가했습니다.

```tsx
const [state, setState] = useState<State>({
  isLike: false,
  count: 0
})

const [error, setError] = useState('')

// 로딩 상태 관리를 위해 useTransition 훅 선언
const [isPending, startTransition] = useTransition()

// useState가 반환한 state를 useOptimistic 훅의
// 초기 값으로 전달
const [optimisticState, toggleOptimisticIsLike] = useOptimistic<State, Value>(
  state,
  updateFn
)

// 컴포넌트가 마운트될 때 현재 좋아요 상태와 개수를 조회
useEffect(() => {
  const fetchData = async () => {
    const response = await fetch('/api/like', { method: 'GET' })
    const data = (await response.json()) as { isLike: boolean; count: number }
    setState(data)
  }

  fetchData();
}, [])
```
- `useState`가 반환한 state를 `useOptimistic`의 초기 값으로 전달합니다.
- `setState`가 호출되어 컴포넌트가 리렌더링 될 때 마다 `useOptimistic`이 새로운 초기 상태와 함께 호출됩니다.

---

### 실제 api 요청 함수 선언

```tsx
const addLike = async () => {
  try {
    const response = await fetch('/api/like', { method: 'POST' })
    if (!response.ok) {
      throw new Error('오류가 발생했습니다.')
    }
    
    const data = (await response.json()) as { isLike: boolean; count: number }
    setState(data)
  } catch (error) {
    if (error instanceof Error) {
      setError(error.message)
    }
  }
}

const removeLike = async () => {
  try {
    const response = await fetch('/api/like', { method: 'DELETE' })
    if (!response.ok) {
      throw new Error('오류가 발생했습니다.')
    }
    
    const data = (await response.json()) as { isLike: boolean; count: number }
    setState(data)
  } catch (error) {
    if (error instanceof Error) {
      setError(error.message)
    }
  }
}

const handleClick = () => {
  startTransition(async () => {
    const nextIsLike = !optimisticState.isLike

    // 💡 낙관적 업데이트
    toggleOptimisticIsLike(nextIsLike)

    if (nextIsLike === true) {
      await addLike()
    } else {
      await removeLike()
    }
  })
}
```
- `handleClick` 함수 내부의 액션에서 다음 좋아요 상태에 따라서 낙관적 업데이트를 먼저 적용하고, `addLike`와 `removeLike` 함수를 호출합니다.
- api 호출에 성공했을 경우
	- api 응답을 `setState`로 인자로 전달하여 호출하고, 컴포넌트가 리렌더링 됩니다.
  - `useOptimistic`이 새로운 초기 상태(state)와 함께 호출되어 낙관적인 상태가 유지됩니다.
- api 호출에 실패했을 경우
  - `setError`가 호출되어 컴포넌트가 리렌더링됩니다.
  - `state`가 변경되지 않았기 때문에 `optimisticState`가 다시 초기 상태로 되돌아갑니다.

---

### 컴포넌트 UI 구현

```tsx
const heartIcon = optimisticState.isLike ?
    <Heart color="#d04e4e" fill="#d04e4e" size={80} /> :
    <Heart color="#d04e4e" size={80} />

return (
  <button type="button" onClick={handleClick}>
    {heartIcon}
    <span>{optimisticState.count}</span>
    {isPending && <div className="text-slate-600">loading...</div>}
    {error && <div className="text-red-600">{error}</div>}
  </button>
)
```
- `optimisticState`를 화면에 렌더링합니다.
- `optimisticState.isLike`에 따라서 하트 아이콘이 전환됩니다.
- api 요청 중인 동안 "loading…"	 텍스트가 화면에 노출됩니다.

---

### API 응답에 따른 UI 변화

![](/posts/react-use-optimistic/example-2.gif)*API 요청에 성공했을 경우*

![](/posts/react-use-optimistic/example-3.gif)*API 요청에 실패했을 경우*

---

## 요약

- 낙관적 업데이트란 비동기 작업이 완료될 때까지 기다리지 않고, 기대되는 결과를 먼저 사용자에게 보여주는 방식입니다.
- React 19에 추가된 useOptimistic 훅은 낙관적 업데이트를 쉽게 구현할 수 있도록 도와줍니다. 훅 내부에서 이전 상태를 관리하고, api 요청이 실패하면 자동으로 이전 상태로 복원되기 때문에 추가적인 상태 관리 로직을 줄일 수 있습니다.
- useOptimistic은 React form action 또는 transition과 함께 사용해야 합니다.

---

전체 코드는 [저장소](https://github.com/kyh196201/react-useOptimistic-example/blob/main/app/LikeButton.tsx)에서 확인할 수 있습니다.

잘못된 내용이 있을 수 있습니다. 피드백은 언제나 환영입니다! 🙂

---

## 참고

- https://medium.com/@kyledeguzmanx/what-are-optimistic-updates-483662c3e171
- [https://velog.io/@kimkanu/React-훅-useOptimistic](https://velog.io/@kimkanu/React-%ED%9B%85-useOptimistic)
- [https://velog.io/@jhjung3/Optimistic-Updates-구현하기-with-리액트-쿼리](https://velog.io/@jhjung3/Optimistic-Updates-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-with-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%BF%BC%EB%A6%AC)